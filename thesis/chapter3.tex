% --- Chapter 3: Implementation ---
\chapter{Реалізація системи}
\label{ch:implementation}

\section{Огляд процесу розробки}
\label{sec:dev_process}
% TODO: Describe development methodology (e.g., Agile, Waterfall), tools used (Git, VS Code, Docker), and workflow.
Розробка веб-застосунку \textit{Beekeepers Community Platform} велася з використанням гнучких підходів, що дозволяли ітеративно додавати функціонал та вносити корективи. Основними інструментами розробки були Visual Studio Code як інтегроване середовище розробки, Git для системи контролю версій (з використанням GitHub для хостингу репозиторію), Docker та Docker Compose для контейнеризації та управління середовищем розробки та розгортання. Робочий процес включав регулярні коміти, розробку у функціональних гілках (за потреби) та тестування ключових функцій на локальному середовищі перед розгортанням.

\section{Організація коду}
\label{sec:code_organization}
Структура коду проекту організована для забезпечення модульності, легкості підтримки та масштабування.

\subsection{Структура проекту фронтенду}
Клієнтська частина (директорія \texttt{client/}) розроблена на React з використанням Vite як інструменту для збірки. Основні директорії в \texttt{src/}:
\begin{itemize}
    \item \texttt{components/}: Містить UI компоненти, розділені за функціональними ознаками (наприклад, \texttt{forum/}, \texttt{map/}, загальні компоненти).
    \item \texttt{pages/}: Компоненти, що відповідають за окремі сторінки застосунку (наприклад, \texttt{Home.tsx}, \texttt{Forums.tsx}, \texttt{MapPage.tsx}).
    \item \texttt{services/} (або \texttt{store/api/}): API-зрізи (slices) для RTK Query, що описують взаємодію з бекенд API (наприклад, \texttt{authApi.ts}, \texttt{forumApi.ts}, \texttt{mapApi.ts}).
    \item \texttt{store/}: Конфігурація Redux store (\texttt{store.ts}).
    \item \texttt{context/}: React Context API для управління глобальним станом, таким як автентифікація (\texttt{AuthContext.tsx}).
    \item \texttt{hooks/}: Спеціалізовані React хуки.
    \item \texttt{types/}: Загальні TypeScript типи та інтерфейси.
    \item \texttt{locales/}: Файли перекладів для інтернаціоналізації (\texttt{en/translation.json}, \texttt{uk/translation.json}).
    \item \texttt{utils/}: Допоміжні функції та утиліти.
    \item \texttt{App.tsx}: Головний компонент застосунку, що налаштовує маршрутизацію.
    \item \texttt{index.tsx} (або \texttt{main.tsx}): Вхідна точка застосунку.
\end{itemize}

\subsection{Структура проекту бекенду}
Серверна частина (директорія \texttt{server/}) розроблена на NestJS. Проект структурований за модульним принципом:
\begin{itemize}
    \item \texttt{src/}: Містить основний код застосунку.
    \item \texttt{src/MODULE\_NAME/}: Кожен функціональний блок (наприклад, \texttt{auth/}, \texttt{users/}, \texttt{forum/}, \texttt{hives/}, \texttt{fields/}, \texttt{health/}, \texttt{email/}) виділений в окремий модуль NestJS.
    \item Кожен модуль зазвичай містить:
        \begin{itemize}
            \item \texttt{*.module.ts}: Файл визначення модуля.
            \item \texttt{*.controller.ts}: Контролер, що обробляє HTTP-запити.
            \item \texttt{*.service.ts}: Сервіс, що інкапсулює бізнес-логіку.
            \item \texttt{schemas/}: Mongoose схеми для визначення структури даних MongoDB.
            \item \texttt{dto/}: Data Transfer Objects для валідації вхідних даних.
            \item \texttt{guards/}, \texttt{strategies/}, \texttt{decorators/}, \texttt{types/} (для специфічних типів модуля, наприклад, в \texttt{auth/}).
        \end{itemize}
    \item \texttt{src/main.ts}: Вхідна точка серверного застосунку, ініціалізація NestJS та Fastify.
    \item \texttt{src/app.module.ts}: Кореневий модуль застосунку.
\end{itemize}

\subsection{Проектування API}
API спроектовано за принципами RESTful. Всі ендпоінти мають префікс \texttt{/api/v1/}, що забезпечує версіонування. Для валідації даних, що надходять від клієнта, використовуються Data Transfer Objects (DTO) з декораторами \texttt{class-validator}. Документація API автоматично генерується за допомогою Swagger (OpenAPI) і доступна на ендпоінті \texttt{/docs} (у середовищі розробки), що спрощує тестування та інтеграцію.

\section{Опис ключових компонентів та модулів}
\label{sec:key_components}

\subsection{Автентифікація та авторизація}
Система автентифікації реалізована з використанням Passport.js. Підтримуються:
\begin{itemize}
    \item \textbf{Локальна стратегія:} Автентифікація за логіном (email) та паролем. Паролі зберігаються у хешованому вигляді (з використанням \texttt{crypto.pbkdf2Sync}).
    \item \textbf{JWT (JSON Web Tokens):} Використовуються для авторизації користувачів після успішного входу. Генеруються access та refresh токени.
    \item \textbf{Верифікація Email:} При реєстрації користувачу надсилається лист з унікальним токеном для підтвердження електронної пошти. Доступ до функціоналу обмежений до верифікації. Термін дії токена -- 1 година.
    \item \textbf{Повторне надсилання листа верифікації:} Реалізовано можливість для користувача запросити повторне надсилання листа для верифікації email, якщо попередній токен сплив або лист не було отримано. Цей функціонал включає новий ендпоінт API (\texttt{/auth/resend-verification-email}) та відповідний інтерфейс на сторінці верифікації (\texttt{VerifyEmailPage.tsx}).
    \item \textbf{Google OAuth 2.0:} Реалізована можливість входу та реєстрації через обліковий запис Google.
    \item \textbf{Захист маршрутів (Guards):} \texttt{JwtAuthGuard} використовується для захисту ендпоінтів, що вимагають автентифікації. \texttt{LocalAuthGuard} використовується для обробки локального входу.
\end{itemize}

\subsection{Форум}
Модуль форуму дозволяє користувачам створювати теми для обговорення, залишати повідомлення та коментарі, а також висловлювати свою думку за допомогою лайків. Дані зберігаються в колекції \texttt{forumposts}. Фронтенд реалізований з використанням компонентів для списку постів, окремого поста та форми створення нового поста. Взаємодія з бекендом відбувається через відповідні API ендпоінти, реалізовані в \texttt{ForumController} та \texttt{ForumService}.

\subsection{База знань}
Модуль бази знань (на даний момент з демонстраційними даними на клієнті) передбачає зберігання та відображення статей, посібників та інших корисних матеріалів для бджолярів. Планується розширення функціоналу для управління контентом через адміністративну панель та реалізація повноцінного API для роботи з ресурсами бази знань.

\subsection{Інтеграція інтерактивної карти}
Одним з ключових функціональних блоків є інтерактивна карта, реалізована за допомогою Leaflet та React-Leaflet на фронтенді та GeoJSON з індексами \texttt{2dsphere} на бекенді (MongoDB). Компонент \texttt{MapPage.tsx} є центральним для цієї функціональності.

\subsubsection{Управління вуликами (Hives)}
\begin{itemize}
    \item \textbf{Додавання вуликів:} Користувачі можуть додавати на карту точкові маркери для позначення вуликів. Через діалогове вікно \texttt{AddHiveDialog.tsx} вказуються назва та нотатки. Геолокація визначається кліком на карті. Дані надсилаються на бекенд за допомогою RTK Query мутації \texttt{useAddHiveMutation}.
    \item \textbf{Відображення вуликів:} Вулики відображаються як кастомні іконки на карті. Для цього використовується бібліотечна іконка \texttt{HiveIcon} з Material-UI, яка рендериться в HTML-рядок за допомогою \texttt{ReactDOMServer.renderToString} та передається в \texttt{L.divIcon} від Leaflet. Це дозволяє уніфікувати візуальний стиль з рештою застосунку.
    \item \textbf{Видалення вуликів:} Користувачі можуть видаляти свої вулики. У спливаючому вікні (Popup) маркера вулика розміщена кнопка видалення. Натискання на неї активує діалогове вікно для підтвердження дії. Після підтвердження, мутація \texttt{useDeleteHiveMutation} з RTK Query відправляє запит на бекенд для видалення відповідного запису з колекції \texttt{hives}.
    \item \textbf{Перегляд інформації:} У спливаючому вікні (Popup) кожного вулика відображається його назва та нотатки.
\end{itemize}

\subsubsection{Управління полями (Fields)}
\begin{itemize}
    \item \textbf{Додавання полів:} Користувачі можуть малювати полігони на карті для позначення полів. Діалогове вікно \texttt{AddFieldDialog.tsx} дозволяє вказати назву поля, тип культури, період цвітіння та список запланованих дат обробки. Геометрія полігону передається на бекенд у форматі GeoJSON. Використовується мутація \texttt{useAddFieldMutation}.
    \item \textbf{Відображення полів:} Поля відображаються як полігони на карті. Колір полігону динамічно змінюється для візуального інформування про заплановані обробки: червоний колір використовується, якщо обробка запланована на поточний день, помаранчевий – якщо протягом наступних 7 днів, і стандартний синій колір в інших випадках. Логіка визначення статусу та вибору кольору реалізована в компоненті \texttt{MapPage.tsx} за допомогою функції \texttt{getFieldTreatmentStatus}.
    \item \textbf{Редагування метаданих полів:} Реалізована можливість редагування інформації про поля (назва, тип культури, період цвітіння, дати обробки). Кнопка редагування у спливаючому вікні поля відкриває діалог \texttt{EditFieldDialog.tsx}, попередньо заповнений поточними даними. Після внесення змін та збереження, дані оновлюються на сервері за допомогою мутації \texttt{useUpdateFieldMutation}.
    \item \textbf{Перегляд інформації:} У спливаючому вікні (Popup) кожного поля відображається його назва, тип культури, період цвітіння та список дат обробки.
\end{itemize}

Бекенд надає відповідні CRUD API ендпоінти для управління вуликами та полями, забезпечуючи збереження, отримання, оновлення та видалення геопросторових об'єктів та їх метаданих (колекції \texttt{hives} та \texttt{fields} у MongoDB).

\subsection{Налаштування доставки транзакційних електронних листів}
\label{subsec:email_delivery}

Для забезпечення надійної та безпечної доставки транзакційних електронних листів (наприклад, для верифікації email), платформа \textit{Beekeepers Community Platform} інтегрується з сервісом Mailgun. Правильне налаштування DNS є критично важливим для доставки та відповідності сучасним галузевим стандартам, особливо тим, що висуваються великими провайдерами, такими як Google та Yahoo.

\subsubsection{Автентифікація домену}

Для автентифікації вихідних електронних листів до DNS-конфігурації домену проекту були додані наступні записи:

\begin{itemize}
    \item \textbf{SPF (Sender Policy Framework):} TXT-запис, що вказує, які поштові сервери мають право надсилати електронні листи від імені домену. Це допомагає запобігти несанкціонованим відправникам (спуфінгу).
    \item \textbf{DKIM (DomainKeys Identified Mail):} TXT-запис, що містить публічний криптографічний ключ. Вихідні листи підписуються приватним ключем Mailgun, а одержувачі можуть перевірити підпис за допомогою публічного ключа в DNS, забезпечуючи цілісність та автентичність повідомлення.
    \item \textbf{DMARC (Domain-based Message Authentication, Reporting, and Conformance):} TXT-запис, який інструктує приймаючі поштові сервери, як обробляти листи, що не пройшли перевірки SPF або DKIM.
        \begin{itemize}
            \item \textbf{Опції політики:}
                \begin{itemize}
                    \item \texttt{p=none}: Тільки моніторинг, без примусових дій.
                    \item \texttt{p=quarantine}: Відправляти листи, що не пройшли перевірку, до папки "Спам".
                    \item \texttt{p=reject}: Повністю блокувати листи, що не пройшли перевірку.
                \end{itemize}
            \item \textbf{Сучасна практика:} Через нові вимоги Google та Yahoo (з 2024 року), політика DMARC повинна бути встановлена щонайменше на \texttt{quarantine} або \texttt{reject} для використання у виробничому середовищі. Це захищає користувачів від фішингу та покращує доставку.
        \end{itemize}
\end{itemize}

\subsubsection{Поширення та верифікація DNS}

Після додавання необхідних записів, поширення змін у DNS може зайняти до 48 годин. Верифікація виконується за допомогою панелі керування Mailgun та сторонніх інструментів (наприклад, MXToolbox), щоб переконатися, що всі записи коректно опубліковані та доступні глобально.

\subsubsection{Безпека та відповідність стандартам}

\begin{itemize}
    \item \textbf{Відсутність жорстко закодованих облікових даних:} Усі API-ключі Mailgun та конфіденційні налаштування зберігаються у змінних середовища, а не в коді.
    \item \textbf{Постійний моніторинг:} Звіти DMARC надсилаються на визначену електронну адресу для моніторингу проблем автентифікації та потенційного зловживання.
    \item \textbf{Ескалація політики:} Проект спочатку використовує \texttt{p=none} для DMARC для моніторингу легітимного трафіку, а потім переходить до \texttt{quarantine} або \texttt{reject} для повної відповідності стандартам та захисту.
\end{itemize}

\subsubsection{Підсумкова таблиця DNS-записів}

\begin{table}[h!]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Запис} & \textbf{Призначення} & \textbf{Приклад значення / Політика} \\
\hline
SPF    & Автентифікація відправника & \texttt{v=spf1 include:mailgun.org \~{}all} \\
DKIM   & Підпис повідомлення & (Публічний ключ, наданий Mailgun) \\
DMARC  & Політика та звіти & \texttt{v=DMARC1; p=quarantine; rua=mailto:admin@domain.com} \\
\hline
\end{tabular}
\caption{Приклади DNS-записів для автентифікації email.}
\label{tab:dns_records_email}
\end{table}

Така конфігурація гарантує, що всі вихідні електронні листи автентифіковані, знижуючи ризик спаму та фішингу та відповідаючи останнім вимогам основних поштових провайдерів. Вона також підтримує моніторинг та постійне вдосконалення безпеки електронної пошти.

\section{Безпека системи}
\label{sec:security_considerations}
При розробці увага приділялася аспектам безпеки:
\begin{itemize}
    \item \textbf{Автентифікація та авторизація:} Використання JWT, захист маршрутів, OAuth 2.0.
    \item \textbf{Зберігання паролів:} Паролі користувачів хешуються на стороні сервера перед збереженням у базу даних (використано модуль \texttt{crypto} Node.js, зокрема \texttt{pbkdf2Sync}).
    \item \textbf{Валідація вхідних даних:} Усі дані, що надходять від клієнта на бекенд, валідуються за допомогою DTO та \texttt{class-validator}, що запобігає некоректним даним та потенційним атакам (наприклад, NoSQL ін'єкції на рівні структури даних).
    \item \textbf{Захист від XSS:} Використання React на фронтенді за замовчуванням екранує дані, що вставляються в DOM, що знижує ризик XSS-атак.
    \item \textbf{CORS:} Налаштовано політику Cross-Origin Resource Sharing для контролю доступу до API з боку фронтенду.
    \item \textbf{Використання HTTPS:} У продакшн-середовищі необхідно використовувати HTTPS для шифрування трафіку.
    \item \textbf{Управління секретами:} Чутливі дані (секрети JWT, ключі API для зовнішніх сервісів, рядок підключення до БД) зберігаються у змінних середовища та не включаються до системи контролю версій.
\end{itemize} 