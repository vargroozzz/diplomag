% --- Chapter 3: Implementation ---
\chapter{Реалізація системи}
\label{ch:implementation}

\section{Огляд процесу розробки}
\label{sec:dev_process}
% TODO: Describe development methodology (e.g., Agile, Waterfall), tools used (Git, VS Code, Docker), and workflow.
Розробка веб-застосунку \textit{Beekeepers Community Platform} велася з використанням гнучких підходів, що дозволяли ітеративно додавати функціонал та вносити корективи. Основними інструментами розробки були Visual Studio Code як інтегроване середовище розробки, Git для системи контролю версій (з використанням GitHub для хостингу репозиторію), Docker та Docker Compose для контейнеризації та управління середовищем розробки та розгортання. Робочий процес включав регулярні коміти, розробку у функціональних гілках (за потреби) та тестування ключових функцій на локальному середовищі перед розгортанням.

\section{Організація коду}
\label{sec:code_organization}
Структура коду проекту організована для забезпечення модульності, легкості підтримки та масштабування.

\subsection{Структура проекту фронтенду}
Клієнтська частина (директорія \texttt{client/}) розроблена на React з використанням Vite як інструменту для збірки. Основні директорії в \texttt{src/}:
\begin{itemize}
    \item \texttt{components/}: Містить UI компоненти, розділені за функціональними ознаками (наприклад, \texttt{forum/}, \texttt{map/}, загальні компоненти).
    \item \texttt{pages/}: Компоненти, що відповідають за окремі сторінки застосунку (наприклад, \texttt{Home.tsx}, \texttt{Forums.tsx}, \texttt{MapPage.tsx}).
    \item \texttt{services/} (або \texttt{store/api/}): API-зрізи (slices) для RTK Query, що описують взаємодію з бекенд API (наприклад, \texttt{authApi.ts}, \texttt{forumApi.ts}, \texttt{mapApi.ts}).
    \item \texttt{store/}: Конфігурація Redux store (\texttt{store.ts}).
    \item \texttt{context/}: React Context API для управління глобальним станом, таким як автентифікація (\texttt{AuthContext.tsx}).
    \item \texttt{hooks/}: Спеціалізовані React хуки.
    \item \texttt{types/}: Загальні TypeScript типи та інтерфейси.
    \item \texttt{locales/}: Файли перекладів для інтернаціоналізації (\texttt{en/translation.json}, \texttt{uk/translation.json}).
    \item \texttt{utils/}: Допоміжні функції та утиліти.
    \item \texttt{App.tsx}: Головний компонент застосунку, що налаштовує маршрутизацію.
    \item \texttt{index.tsx} (або \texttt{main.tsx}): Вхідна точка застосунку.
\end{itemize}

\subsection{Структура проекту бекенду}
Серверна частина (директорія \texttt{server/}) розроблена на NestJS. Проект структурований за модульним принципом:
\begin{itemize}
    \item \texttt{src/}: Містить основний код застосунку.
    \item \texttt{src/MODULE\_NAME/}: Кожен функціональний блок (наприклад, \texttt{auth/}, \texttt{users/}, \texttt{forum/}, \texttt{hives/}, \texttt{fields/}, \texttt{health/}, \texttt{email/}) виділений в окремий модуль NestJS.
    \item Кожен модуль зазвичай містить:
        \begin{itemize}
            \item \texttt{*.module.ts}: Файл визначення модуля.
            \item \texttt{*.controller.ts}: Контролер, що обробляє HTTP-запити.
            \item \texttt{*.service.ts}: Сервіс, що інкапсулює бізнес-логіку.
            \item \texttt{schemas/}: Mongoose схеми для визначення структури даних MongoDB.
            \item \texttt{dto/}: Data Transfer Objects для валідації вхідних даних.
            \item \texttt{guards/}, \texttt{strategies/}, \texttt{decorators/}, \texttt{types/} (для специфічних типів модуля, наприклад, в \texttt{auth/}).
        \end{itemize}
    \item \texttt{src/main.ts}: Вхідна точка серверного застосунку, ініціалізація NestJS та Fastify.
    \item \texttt{src/app.module.ts}: Кореневий модуль застосунку.
\end{itemize}

\subsection{Проектування API}
API спроектовано за принципами RESTful. Всі ендпоінти мають префікс \texttt{/api/v1/}, що забезпечує версіонування. Для валідації даних, що надходять від клієнта, використовуються Data Transfer Objects (DTO) з декораторами \texttt{class-validator}. Документація API автоматично генерується за допомогою Swagger (OpenAPI) і доступна на ендпоінті \texttt{/docs} (у середовищі розробки), що спрощує тестування та інтеграцію.

\section{Опис ключових компонентів та модулів}
\label{sec:key_components}

\subsection{Автентифікація та авторизація}
Система автентифікації реалізована з використанням Passport.js. Підтримуються:
\begin{itemize}
    \item \textbf{Локальна стратегія:} Автентифікація за логіном (email) та паролем. Паролі зберігаються у хешованому вигляді (з використанням \texttt{crypto.pbkdf2Sync}).
    \item \textbf{JWT (JSON Web Tokens):} Використовуються для авторизації користувачів після успішного входу. Генеруються access та refresh токени.
    \item \textbf{Верифікація Email:} При реєстрації користувачу надсилається лист з унікальним токеном для підтвердження електронної пошти. Доступ до функціоналу обмежений до верифікації. Термін дії токена -- 1 година.
    \item \textbf{Повторне надсилання листа верифікації:} Реалізовано можливість для користувача запросити повторне надсилання листа для верифікації email, якщо попередній токен сплив або лист не було отримано. Цей функціонал включає новий ендпоінт API (\texttt{/auth/resend-verification-email}) та відповідний інтерфейс на сторінці верифікації (\texttt{VerifyEmailPage.tsx}).
    \item \textbf{Google OAuth 2.0:} Реалізована можливість входу та реєстрації через обліковий запис Google.
    \item \textbf{Захист маршрутів (Guards):} \texttt{JwtAuthGuard} використовується для захисту ендпоінтів, що вимагають автентифікації. \texttt{LocalAuthGuard} використовується для обробки локального входу.
\end{itemize}

\subsection{Форум}
Модуль форуму дозволяє користувачам створювати теми для обговорення, залишати повідомлення та коментарі, а також висловлювати свою думку за допомогою лайків. Дані зберігаються в колекції \texttt{forumposts}. Фронтенд реалізований з використанням компонентів для списку постів, окремого поста та форми створення нового поста. Взаємодія з бекендом відбувається через відповідні API ендпоінти, реалізовані в \texttt{ForumController} та \texttt{ForumService}.

\subsection{База знань}
Модуль бази знань (на даний момент з демонстраційними даними на клієнті) передбачає зберігання та відображення статей, посібників та інших корисних матеріалів для бджолярів. Планується розширення функціоналу для управління контентом через адміністративну панель та реалізація повноцінного API для роботи з ресурсами бази знань.

\subsection{Інтеграція інтерактивної карти}
Одним з ключових функціональних блоків є інтерактивна карта, реалізована за допомогою Leaflet та React-Leaflet на фронтенді та GeoJSON з індексами \texttt{2dsphere} на бекенді (MongoDB). Компонент \texttt{MapPage.tsx} є центральним для цієї функціональності.

\subsubsection{Управління вуликами (Hives)}
\begin{itemize}
    \item \textbf{Додавання вуликів:} Користувачі можуть додавати на карту точкові маркери для позначення вуликів. Через діалогове вікно \texttt{AddHiveDialog.tsx} вказуються назва та нотатки. Геолокація визначається кліком на карті. Дані надсилаються на бекенд за допомогою RTK Query мутації \texttt{useAddHiveMutation}.
    
    \item \textbf{Відображення вуликів з кастомними іконками:} 
    Стандартні маркери бібліотеки Leaflet є досить загальними. Для покращення візуального сприйняття та тематичної відповідності було реалізовано відображення вуликів на карті за допомогою кастомних іконок. В якості візуального образу було обрано іконку \texttt{HiveIcon} з бібліотеки Material-UI, що забезпечує стилістичну єдність з іншими елементами інтерфейсу платформи. 
    
    Оскільки Leaflet очікує HTML-рядок або DOM-елемент для кастомних маркерів через \texttt{L.divIcon}, а \texttt{HiveIcon} є React-компонентом, було застосовано наступне рішення. За допомогою функції \texttt{ReactDOMServer.renderToString()} з пакету \texttt{react-dom/server} (яка зазвичай використовується для серверного рендерингу) React-компонент іконки перетворюється на статичний HTML-рядок на стороні клієнта. Цей рядок потім передається у властивість \texttt{html} об'єкта конфігурації \texttt{L.divIcon}. 
    
    При створенні кастомної іконки також налаштовуються важливі параметри \texttt{L.divIcon}, такі як \texttt{className} (для можливості додаткової CSS-стилізації), \texttt{iconSize} (розмір іконки), \texttt{iconAnchor} (точка прив'язки іконки до географічних координат, щоб вістря іконки вказувало на точне місце), та \texttt{popupAnchor} (позиціонування спливаючого вікна відносно іконки). Сформований таким чином об'єкт \texttt{hiveLeafletIcon} потім передається у пропс \texttt{icon} компонента \texttt{<Marker>} з бібліотеки React-Leaflet. Такий підхід дозволив ефективно інтегрувати React-компоненти Material-UI в картографічний контекст Leaflet, забезпечуючи кращий користувацький досвід та візуальну привабливість карти.

    \item \textbf{Видалення вуликів:} Користувачі можуть видаляти свої вулики. У спливаючому вікні (Popup) маркера вулика розміщена кнопка видалення. Натискання на неї активує діалогове вікно для підтвердження дії. Після підтвердження, мутація \texttt{useDeleteHiveMutation} з RTK Query відправляє запит на бекенд для видалення відповідного запису з колекції \texttt{hives}.
    \item \textbf{Перегляд інформації:} У спливаючому вікні (Popup) кожного вулика відображається його назва та нотатки.
\end{itemize}

\subsubsection{Управління полями (Fields)}
\begin{itemize}
    \item \textbf{Додавання полів:} Користувачі можуть малювати полігони на карті для позначення полів. Діалогове вікно \texttt{AddFieldDialog.tsx} дозволяє вказати назву поля, тип культури, період цвітіння та список запланованих дат обробки. Геометрія полігону передається на бекенд у форматі GeoJSON. Використовується мутація \texttt{useAddFieldMutation}.
    
    \item \textbf{Відображення полів та візуалізація статусу обробки:} 
    Поля відображаються як полігони на карті за допомогою компонента \texttt{<Polygon>} з бібліотеки React-Leaflet. Ключовою особливістю є динамічна зміна кольору полігону для візуального інформування бджолярів про заплановані хімічні обробки полів, що можуть становити загрозу для бджіл. Ця логіка реалізована в компоненті \texttt{MapPage.tsx} у функції \texttt{getFieldTreatmentStatus}. 
    
    Функція приймає масив дат обробок для конкретного поля. Вона порівнює кожну дату обробки з поточною датою. Якщо обробка запланована на сьогодні, полю присвоюється червоний колір (високий ризик). Якщо обробка запланована протягом наступних семи днів (визначено константою \texttt{TREATMENT\_SOON\_DAYS}), полю присвоюється помаранчевий колір (середній ризик). В інших випадках використовується стандартний синій колір. Перевірка на "сьогодні" здійснюється за допомогою допоміжної функції \texttt{isSameDay}, яка порівнює рік, місяць та день двох дат. Результатом роботи \texttt{getFieldTreatmentStatus} є об'єкт, що містить властивість \texttt{color}, значення якої динамічно передається в атрибут \texttt{pathOptions} компонента \texttt{<Polygon>}. Для оптимізації та уникнення зайвих перерахунків при кожному рендері компонента, функція \texttt{getFieldTreatmentStatus} обгорнута в React хук \texttt{useMemo} (хоча в поточній реалізації без залежностей вона створюється один раз). Це забезпечує користувачам наочне та оперативне сповіщення про потенційні загрози.

    \item \textbf{Редагування метаданих полів:} 
    Для модифікації атрибутів існуючих полів було розроблено спеціалізований діалоговий компонент \texttt{EditFieldDialog.tsx}. Активація цього діалогу відбувається при натисканні користувачем кнопки редагування у спливаючому вікні (Popup) відповідного полігону поля на карті. Компонент отримує через пропси поточні дані поля (\texttt{initialData}), прапорець видимості (\texttt{open}), обробники закриття (\texttt{onClose}) та відправки форми (\texttt{onSubmit}), а також стан завантаження (\texttt{isLoading}) для індикації процесу взаємодії з API.
    
    Внутрішній стан форми (\texttt{formData}), що включає назву, тип культури, дати початку та кінця цвітіння, а також список дат обробки, управляється за допомогою хука \texttt{useState}. При відкритті діалогу або зміні \texttt{initialData}, хук \texttt{useEffect} відповідає за ініціалізацію стану форми даними обраного поля. Важливим аспектом є перетворення форматів дат: рядкові ISO-дати, отримані з бекенду, форматуються у вигляд \texttt{YYYY-MM-DD}, сумісний з HTML-елементами вводу типу \texttt{date}.
    
    Обробка змін у текстових полях форми реалізована через універсальний обробник \texttt{handleChange}. Для управління динамічним списком дат обробки передбачені окремі функції: \texttt{addTreatmentDate} для додавання нового поля вводу дати, \texttt{removeTreatmentDate} для видалення існуючого, та \texttt{handleTreatmentDateChange} для оновлення конкретної дати у списку. 
    
    При відправці форми функція \texttt{handleSubmit} виконує базову валідацію введених даних. Якщо валідація успішна, викликається переданий через пропси обробник \texttt{onSubmit} (визначений у \texttt{MapPage.tsx}). Цей обробник, у свою чергу, активує RTK Query мутацію \texttt{useUpdateFieldMutation}, передаючи ідентифікатор поля (\texttt{\_id}) та об'єкт \texttt{formData} з оновленими даними на сервер. Протягом виконання асинхронного запиту до API, пропс \texttt{isLoading} використовується для блокування елементів форми та відображення індикатора завантаження на кнопці збереження, забезпечуючи користувачеві зворотний зв'язок.

    \item \textbf{Перегляд інформації:} У спливаючому вікні (Popup) кожного поля відображається його назва, тип культури, період цвітіння та список дат обробки.
\end{itemize}

Бекенд надає відповідні CRUD API ендпоінти для управління вуликами та полями, забезпечуючи збереження, отримання, оновлення та видалення геопросторових об'єктів та їх метаданих (колекції \texttt{hives} та \texttt{fields} у MongoDB).

\subsection{Налаштування доставки транзакційних електронних листів}
\label{subsec:email_delivery}

Для забезпечення надійної та безпечної доставки транзакційних електронних листів (наприклад, для верифікації email), платформа \textit{Beekeepers Community Platform} інтегрується з сервісом Mailgun. Правильне налаштування DNS є критично важливим для доставки та відповідності сучасним галузевим стандартам, особливо тим, що висуваються великими провайдерами, такими як Google та Yahoo.

\subsubsection{Автентифікація домену}

Для автентифікації вихідних електронних листів до DNS-конфігурації домену проекту були додані наступні записи:

\begin{itemize}
    \item \textbf{SPF (Sender Policy Framework):} TXT-запис, що вказує, які поштові сервери мають право надсилати електронні листи від імені домену. Це допомагає запобігти несанкціонованим відправникам (спуфінгу).
    \item \textbf{DKIM (DomainKeys Identified Mail):} TXT-запис, що містить публічний криптографічний ключ. Вихідні листи підписуються приватним ключем Mailgun, а одержувачі можуть перевірити підпис за допомогою публічного ключа в DNS, забезпечуючи цілісність та автентичність повідомлення.
    \item \textbf{DMARC (Domain-based Message Authentication, Reporting, and Conformance):} TXT-запис, який інструктує приймаючі поштові сервери, як обробляти листи, що не пройшли перевірки SPF або DKIM.
        \begin{itemize}
            \item \textbf{Опції політики:}
                \begin{itemize}
                    \item \texttt{p=none}: Тільки моніторинг, без примусових дій.
                    \item \texttt{p=quarantine}: Відправляти листи, що не пройшли перевірку, до папки "Спам".
                    \item \texttt{p=reject}: Повністю блокувати листи, що не пройшли перевірку.
                \end{itemize}
            \item \textbf{Сучасна практика:} Через нові вимоги Google та Yahoo (з 2024 року), політика DMARC повинна бути встановлена щонайменше на \texttt{quarantine} або \texttt{reject} для використання у виробничому середовищі. Це захищає користувачів від фішингу та покращує доставку.
        \end{itemize}
\end{itemize}

\subsubsection{Поширення та верифікація DNS}

Після додавання необхідних записів, поширення змін у DNS може зайняти до 48 годин. Верифікація виконується за допомогою панелі керування Mailgun та сторонніх інструментів (наприклад, MXToolbox), щоб переконатися, що всі записи коректно опубліковані та доступні глобально.

\subsubsection{Безпека та відповідність стандартам}

\begin{itemize}
    \item \textbf{Відсутність жорстко закодованих облікових даних:} Усі API-ключі Mailgun та конфіденційні налаштування зберігаються у змінних середовища, а не в коді.
    \item \textbf{Постійний моніторинг:} Звіти DMARC надсилаються на визначену електронну адресу для моніторингу проблем автентифікації та потенційного зловживання.
    \item \textbf{Ескалація політики:} Проект спочатку використовує \texttt{p=none} для DMARC для моніторингу легітимного трафіку, а потім переходить до \texttt{quarantine} або \texttt{reject} для повної відповідності стандартам та захисту.
\end{itemize}

\subsubsection{Підсумкова таблиця DNS-записів}

\begin{table}[h!]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Запис} & \textbf{Призначення} & \textbf{Приклад значення / Політика} \\
\hline
SPF    & Автентифікація відправника & \texttt{v=spf1 include:mailgun.org \~{}all} \\
DKIM   & Підпис повідомлення & (Публічний ключ, наданий Mailgun) \\
DMARC  & Політика та звіти & \texttt{v=DMARC1; p=quarantine; rua=mailto:admin@domain.com} \\
\hline
\end{tabular}
\caption{Приклади DNS-записів для автентифікації email.}
\label{tab:dns_records_email}
\end{table}

Така конфігурація гарантує, що всі вихідні електронні листи автентифіковані, знижуючи ризик спаму та фішингу та відповідаючи останнім вимогам основних поштових провайдерів. Вона також підтримує моніторинг та постійне вдосконалення безпеки електронної пошти.

\section{Безпека системи}
\label{sec:security_considerations}
При розробці увага приділялася аспектам безпеки:
\begin{itemize}
    \item \textbf{Автентифікація та авторизація:} Використання JWT, захист маршрутів, OAuth 2.0.
    \item \textbf{Зберігання паролів:} Паролі користувачів хешуються на стороні сервера перед збереженням у базу даних (використано модуль \texttt{crypto} Node.js, зокрема \texttt{pbkdf2Sync}).
    \item \textbf{Валідація вхідних даних:} Усі дані, що надходять від клієнта на бекенд, валідуються за допомогою DTO та \texttt{class-validator}, що запобігає некоректним даним та потенційним атакам (наприклад, NoSQL ін'єкції на рівні структури даних).
    \item \textbf{Захист від XSS:} Використання React на фронтенді за замовчуванням екранує дані, що вставляються в DOM, що знижує ризик XSS-атак.
    \item \textbf{CORS:} Налаштовано політику Cross-Origin Resource Sharing для контролю доступу до API з боку фронтенду.
    \item \textbf{Використання HTTPS:} У продакшн-середовищі необхідно використовувати HTTPS для шифрування трафіку.
    \item \textbf{Управління секретами:} Чутливі дані (секрети JWT, ключі API для зовнішніх сервісів, рядок підключення до БД) зберігаються у змінних середовища та не включаються до системи контролю версій.
\end{itemize} 